<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="description" content="Lode Runner" />
		<title>Lode Runner par Marc-Olivier Lalonde</title>
		<link rel="stylesheet" type="text/css" href="StyleLabo5.css" />
		<link rel="javascript" href="echelle.js" />

		<!-- Code JavaScript local -->
		<script type="text/javascript">
			let objCanvas = null
			let objC2D = null
			let objCycleAnimation = null
			let intHauteurCellule = null
			let intLongueurCellule = null

			let objBrique = null
			let objEchelle = null
			let objTextureBois = null
			let objBarreFranchissement = null
			let objImageOr = null
			let objOr = null

			let objGarde1 = null
			let objGarde2 = null
			let objGarde3 = null
			let objLodeRunner = null

			const intVitesse = 2

			let binEnMouvement = false
			let binTombeActuel = false

			/*
							" " = case vide (espace dans les guillemets)
							"o" = or
							"b" = brique
							"e" = echelle
							"f" = barre de franchissement
							"p" = plancher gris
						*/
			// prettier-ignore
			let tTableauDeJeu = [
																	[" "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "],
																	[" "," "," "," ","o"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "],
																	["b","b","b","b","b","b","b","e","b","b","b","b","b","b","b"," "," "," "," "," "," "," "," "," "," "," "," "," "],
																	[" "," "," "," "," "," "," ","e","f","f","f","f","f","f","f","f","f","f"," "," "," "," "," ","o"," "," "," "," "],
																	[" "," "," "," "," "," "," ","e"," "," "," "," ","b","b","e"," "," "," ","b","b","b","b","b","b","b","e","b","b"],
																	[" "," "," "," "," "," "," ","e"," "," "," "," ","b","b","e"," "," "," "," "," "," "," "," "," "," ","e"," "," "],
																	[" "," "," "," "," "," "," ","e"," "," "," "," ","b","b","e"," "," "," "," "," "," "," ","o"," "," ","e"," "," "],
																	["b","b","e","b","b","b","b","b"," "," "," "," ","b","b","b","b","b","b","b","b","e","b","b","b","b","b","b","b"],
																	[" "," ","e"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "],
																	[" "," ","e"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "],
																	["b","b","b","b","b","b","b","b","b","e","b","b","b","b","b","b","b","b","b","b","e"," "," "," "," "," "," "," "],
																	[" "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "],
																	[" "," "," "," "," "," "," ","o"," ","e","f","f","f","f","f","f","f","f","f","f","e"," "," "," ","o"," "," "," "],
																	[" "," "," "," ","e","b","b","b","b","b","b"," "," "," "," "," "," "," "," "," ","b","b","b","b","b","b","b","e"],
																	[" "," "," "," ","e"," "," "," "," "," "," "," "," "," "," "," "," "," ","o"," "," "," "," "," "," "," "," ","e"],
																	["b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b"],
																	["p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p"]
																]

			const initAnimation = () => {
				objCanvas = document.getElementById("monCanvas")
				objCanvas.focus()
				objC2D = objCanvas.getContext("2d")
				intLongueurCellule = objCanvas.width / 28
				intHauteurCellule = objCanvas.height / 17
				initFond()
				initBrique()
				initEchelle()
				initBarreFranchissement()
				initOr()
				initTableauJeu()
				initObjLodeRunner()
				initGardes()

				//console.log(objGarde1.intPosYActuel)
				//console.table(objBrique.tPos)

				dessiner() // Dessiner une première fois
				animer()
			}

			const initFond = () => {
				objFond = new Object()
				objFond.strCouleur = "black"
			}

			const initBrique = () => {
				objBrique = new Object()
				objBrique.tPos = []
				objBrique.strCouleurBrique = "red"
				objBrique.strCouleurCiment = "gray"
			}

			const initEchelle = () => {
				// 50 x 40
				objEchelle = new Object()
				objEchelle.tPos = []
				objEchelle.strCouleur = "#87542D"
			}

			const initBarreFranchissement = () => {
				objBarreFranchissement = new Object()
				objBarreFranchissement.tPos = []
				objBarreFranchissement.strCouleur = "orange"
			}

			const initOr = () => {
				objImageOr = new Image()
				objImageOr.src = "Images/tresor.png"

				objOr = new Object()
				objOr.tPos = []
			}

			const initTableauJeu = () => {
				// intit chaque objet for ij loop pour push position dans chaque objetfixe.
				for (let i = 0; i < tTableauDeJeu.length; i++) {
					for (let j = 0; j < tTableauDeJeu[i].length; j++) {
						switch (tTableauDeJeu[i][j]) {
							case "b":
								objBrique.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							case "e":
								objEchelle.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							case "f":
								objBarreFranchissement.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							case "o":
								objOr.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							default:
								break
						}
					}
				}
			}

			const initGardes = () => {
				objGarde1 = new Object()
				objGarde1.intPosXActuel = 7 * intLongueurCellule
				objGarde1.intPosYActuel = 12 * intHauteurCellule
				objGarde1.strCouleur = "red"
				objGarde1.intVitesse = intVitesse * 0.8
				objGarde1.binVaTomber = false
				objGarde1.binEnMouvement = false
				objGarde1.binTombe = false
				objGarde1.binVaTomber = false
				objGarde1.intPosYAvantChute = 0

				objGarde2 = new Object()
				objGarde2.intPosXActuel = 8 * intLongueurCellule
				objGarde2.intPosYActuel = 9 * intHauteurCellule
				objGarde2.strCouleur = "green"
				objGarde2.intVitesse = intVitesse * 0.8
				objGarde2.binVaTomber = false
				objGarde2.binEnMouvement = false
				objGarde2.binTombe = false
				objGarde2.binVaTomber = false
				objGarde2.intPosYAvantChute = 0

				objGarde3 = new Object()
				objGarde3.intPosXActuel = 12 * intLongueurCellule
				objGarde3.intPosYActuel = 3 * intHauteurCellule
				objGarde3.strCouleur = "purple"
				objGarde3.intVitesse = intVitesse * 0.8
				objGarde3.binVaTomber = false
				objGarde3.binEnMouvement = false
				objGarde3.binTombe = false
				objGarde3.binVaTomber = false
				objGarde3.intPosYAvantChute = 0
			}

			const animer = () => {
				// Requête pour le prochain cycle
				objCycleAnimation = requestAnimationFrame(animer)

				// Le cycle d'animation
				effacerDessin()
				mettreAJourAnimation()
				dessiner()
			}

			const effacerDessin = () => {
				objC2D.clearRect(0, 0, objCanvas.width, objCanvas.height)
			}

			const mettreAJourAnimation = () => {
				mettreAJourAnimationLoneRunner()
				if (objGarde1.intPosXActuel + 10) mouvementGarde()
			}

			const arreterAnimation = () => {
				if (objCycleAnimation != null) cancelAnimationFrame(objCycleAnimation)
				objCycleAnimation = null
			}

			const dessiner = () => {
				dessinerFond()
				dessinerBrique()
				dessinerEchelle()
				dessinerBarreFranchissement()
				dessinerOr()
				dessinerLodeRunner()
				dessinerGardes()
			}

			const dessinerFond = () => {
				objC2D.save()
				objC2D.beginPath()
				objC2D.fillStyle = objFond.strCouleur
				objC2D.rect(0, 0, objCanvas.width, objCanvas.height)
				objC2D.fill()
				objC2D.restore()
			}

			const dessinerBrique = () => {
				objC2D.save()
				for (let index = 0; index < objBrique.tPos.length; index++) {
					let intPosXActuel = objBrique.tPos[index].x
					let intPosYActuel = objBrique.tPos[index].y

					objC2D.fillStyle = "red"
					objC2D.beginPath()
					objC2D.rect(intPosXActuel, intPosYActuel, intLongueurCellule, intHauteurCellule)
					objC2D.fill()

					objC2D.strokeStyle = "gray"
					objC2D.lineWidth = 3
					objC2D.beginPath()
					objC2D.moveTo(intPosXActuel, intPosYActuel)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel)
					objC2D.moveTo(intPosXActuel, intPosYActuel + intHauteurCellule)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + intHauteurCellule)
					objC2D.moveTo(intPosXActuel + intLongueurCellule / 3, intPosYActuel + intHauteurCellule)
					objC2D.lineTo(
						intPosXActuel + intLongueurCellule / 3,
						intPosYActuel + intHauteurCellule / 2
					)
					objC2D.moveTo(intPosXActuel + (2 * intLongueurCellule) / 3, intPosYActuel)
					objC2D.lineTo(
						intPosXActuel + (2 * intLongueurCellule) / 3,
						intPosYActuel + intHauteurCellule / 2
					)
					objC2D.stroke()

					objC2D.strokeStyle = "gray"
					objC2D.lineWidth = 5
					objC2D.beginPath()
					objC2D.moveTo(intPosXActuel, intPosYActuel + intHauteurCellule / 2)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + intHauteurCellule / 2)
					objC2D.stroke()
				}
				objC2D.restore()
			}

			const dessinerEchelle = () => {
				objC2D.save()
				for (let index = 0; index < objEchelle.tPos.length; index++) {
					let intPosXActuel = objEchelle.tPos[index].x
					let intPosYActuel = objEchelle.tPos[index].y

					objC2D.strokeStyle = objEchelle.strCouleur
					objC2D.lineWidth = 5
					objC2D.beginPath()
					// bareau de gauche
					objC2D.moveTo(intPosXActuel + 2.5, intPosYActuel - 1.5)
					objC2D.lineTo(intPosXActuel + 2.5, intPosYActuel + intHauteurCellule - 1)
					objC2D.stroke()
					// bareau de droite
					objC2D.moveTo(intPosXActuel + intLongueurCellule - 2.5, intPosYActuel - 1.5)
					objC2D.lineTo(
						intPosXActuel + intLongueurCellule - 2.5,
						intPosYActuel + intHauteurCellule - 1
					)
					objC2D.stroke()
					objC2D.lineWidth = 2
					// bareau du haut et les autres en dessous
					objC2D.moveTo(intPosXActuel, intPosYActuel + 2)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 2)
					objC2D.moveTo(intPosXActuel, intPosYActuel + 12)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 12)
					objC2D.moveTo(intPosXActuel, intPosYActuel + 22)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 22)
					objC2D.moveTo(intPosXActuel, intPosYActuel + 32)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 32)
					objC2D.stroke()
				}
				let intPosXActuel = objEchelle.tPos[0].x
				let intPosYActuel = objEchelle.tPos[0].y

				objC2D.restore()
			}

			const dessinerBarreFranchissement = () => {
				objC2D.save()
				for (let index = 0; index < objBarreFranchissement.tPos.length; index++) {
					let intPosXActuel = objBarreFranchissement.tPos[index].x
					let intPosYActuel = objBarreFranchissement.tPos[index].y

					objC2D.strokeStyle = objBarreFranchissement.strCouleur
					objC2D.lineWidth = 2
					objC2D.beginPath()
					objC2D.moveTo(intPosXActuel, intPosYActuel + 10)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 10)
					objC2D.stroke()
				}
			}

			const dessinerOr = () => {
				objC2D.save()
				for (let index = 0; index < objOr.tPos.length; index++) {
					let intPosXActuel = objOr.tPos[index].x
					let intPosYActuel = objOr.tPos[index].y

					objC2D.beginPath()
					objC2D.drawImage(
						objImageOr,
						intPosXActuel + 5,
						intPosYActuel + 15,
						intLongueurCellule - 5,
						intHauteurCellule - 15
					)
				}
				objC2D.restore()
			}

			const initObjLodeRunner = () => {
				objLodeRunner = new Object()
				objLodeRunner.intPosXActuel =
					15 * intLongueurCellule - intLongueurCellule / 2 + intLongueurCellule / 2
				objLodeRunner.intPosYActuel = 14 * intHauteurCellule + intHauteurCellule - 2
				objLodeRunner.intVitesse = intVitesse
				objLodeRunner.intScaleX = 1
				objLodeRunner.binMovDroite = false
				objLodeRunner.binMovGauche = false
			}

			const dessinerLodeRunner = () => {
				objC2D.save()
				objC2D.translate(objLodeRunner.intPosXActuel, objLodeRunner.intPosYActuel)
				objC2D.scale(objLodeRunner.intScaleX, 1)

				objC2D.strokeStyle = "white"
				// pied droit
				objC2D.beginPath()
				objC2D.lineWidth = 6
				objC2D.moveTo(3, 0)
				objC2D.lineTo(3, -7)
				objC2D.stroke()
				// jambe droite
				objC2D.beginPath()
				objC2D.lineWidth = 3
				objC2D.moveTo(1.5, -7)
				objC2D.lineTo(1.5, -11)
				objC2D.stroke()
				// corps
				objC2D.beginPath()
				objC2D.lineWidth = 7
				objC2D.moveTo(-7 / 2, -8)
				objC2D.lineTo(-7 / 2, -20)
				objC2D.stroke()
				// jambe droite
				objC2D.beginPath()
				objC2D.lineWidth = 4
				objC2D.moveTo(-4, -6)
				objC2D.lineTo(-15, -6)
				objC2D.stroke()
				// epaule droite
				objC2D.beginPath()
				objC2D.lineWidth = 3
				objC2D.moveTo(-4, -21.5)
				objC2D.lineTo(6, -21.5)
				objC2D.stroke()
				// bras droite
				objC2D.beginPath()
				objC2D.moveTo(6, -18.5)
				objC2D.lineTo(11, -18.5)
				objC2D.stroke()
				// cou
				objC2D.beginPath()
				objC2D.moveTo(1, -24.5)
				objC2D.lineTo(-7, -24.5)
				objC2D.stroke()
				// epaule gauche
				objC2D.beginPath()
				objC2D.moveTo(-7, -21.5)
				objC2D.lineTo(-12, -21.5)
				objC2D.stroke()
				// bras gauche
				objC2D.beginPath()
				objC2D.moveTo(-10, -18.5)
				objC2D.lineTo(-15, -18.5)
				objC2D.stroke()
				// tete
				objC2D.beginPath()
				objC2D.lineWidth = 8
				objC2D.moveTo(0, -26)
				objC2D.lineTo(0, -32)
				objC2D.stroke()
				// chapeau
				objC2D.beginPath()
				objC2D.strokeStyle = "cyan"
				objC2D.lineWidth = 4
				objC2D.moveTo(0, -32)
				objC2D.lineTo(0, -35)
				objC2D.stroke()

				objC2D.restore()
			}

			const dessinerGardes = () => {
				objC2D.save()
				let intPosXActuel = null
				let intPosYActuel = null
				let strCouleurGarde = ""

				for (let i = 1; i <= 3; i++) {
					if (i == 1) {
						strCouleurGarde = objGarde1.strCouleur
						intPosXActuel = objGarde1.intPosXActuel
						intPosYActuel = objGarde1.intPosYActuel
					} else if (i == 2) {
						strCouleurGarde = objGarde2.strCouleur
						intPosXActuel = objGarde2.intPosXActuel
						intPosYActuel = objGarde2.intPosYActuel
					} else {
						strCouleurGarde = objGarde3.strCouleur
						intPosXActuel = objGarde3.intPosXActuel
						intPosYActuel = objGarde3.intPosYActuel
					}

					intPosPlancherY = intPosYActuel + intHauteurCellule - 2
					intPosCentreX = intPosXActuel + intLongueurCellule / 2

					objC2D.beginPath()
					objC2D.rect(intPosXActuel, intPosYActuel, intLongueurCellule, intHauteurCellule)
					objC2D.stroke()

					// Dessiner a partir du base au centre de la cellule
					objC2D.strokeStyle = "white"
					// pied droit
					objC2D.beginPath()
					objC2D.lineWidth = 6
					objC2D.moveTo(intPosCentreX + 3, intPosPlancherY)
					objC2D.lineTo(intPosCentreX + 3, intPosPlancherY - 7)
					objC2D.stroke()
					// jambe droite
					objC2D.beginPath()
					objC2D.lineWidth = 3
					objC2D.moveTo(intPosCentreX + 1.5, intPosPlancherY - 7)
					objC2D.lineTo(intPosCentreX + 1.5, intPosPlancherY - 11)
					objC2D.stroke()
					// fesse
					objC2D.strokeStyle = "white"
					objC2D.beginPath()
					objC2D.lineWidth = 7
					objC2D.moveTo(intPosCentreX - 7 / 2, intPosPlancherY - 8)
					objC2D.lineTo(intPosCentreX - 7 / 2, intPosPlancherY - 16)
					objC2D.stroke()
					// corps
					objC2D.strokeStyle = strCouleurGarde
					objC2D.beginPath()
					objC2D.lineWidth = 7
					objC2D.moveTo(intPosCentreX - 7 / 2, intPosPlancherY - 16)
					objC2D.lineTo(intPosCentreX - 7 / 2, intPosPlancherY - 20)
					objC2D.stroke()
					objC2D.strokeStyle = "white"
					// jambe droite
					objC2D.beginPath()
					objC2D.lineWidth = 4
					objC2D.moveTo(intPosCentreX - 4, intPosPlancherY - 6)
					objC2D.lineTo(intPosCentreX - 15, intPosPlancherY - 6)
					objC2D.stroke()
					objC2D.strokeStyle = strCouleurGarde
					// epaule droite
					objC2D.beginPath()
					objC2D.lineWidth = 3
					objC2D.moveTo(intPosCentreX - 4, intPosPlancherY - 21.5)
					objC2D.lineTo(intPosCentreX + 6, intPosPlancherY - 21.5)
					objC2D.stroke()
					// bras droite
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX + 6, intPosPlancherY - 18.5)
					objC2D.lineTo(intPosCentreX + 11, intPosPlancherY - 18.5)
					objC2D.stroke()
					// cou
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX + 1, intPosPlancherY - 24.5)
					objC2D.lineTo(intPosCentreX - 7, intPosPlancherY - 24.5)
					objC2D.stroke()
					// epaule gauche
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX - 7, intPosPlancherY - 21.5)
					objC2D.lineTo(intPosCentreX - 12, intPosPlancherY - 21.5)
					objC2D.stroke()
					// bras gauche
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX - 10, intPosPlancherY - 18.5)
					objC2D.lineTo(intPosCentreX - 15, intPosPlancherY - 18.5)
					objC2D.stroke()
					objC2D.strokeStyle = "BurlyWood"
					// tete
					objC2D.beginPath()
					objC2D.lineWidth = 8
					objC2D.moveTo(intPosCentreX, intPosPlancherY - 26)
					objC2D.lineTo(intPosCentreX, intPosPlancherY - 32)
					objC2D.stroke()
					// chapeau
					objC2D.beginPath()
					objC2D.strokeStyle = "cyan"
					objC2D.lineWidth = 4
					objC2D.moveTo(intPosCentreX, intPosPlancherY - 32)
					objC2D.lineTo(intPosCentreX, intPosPlancherY - 35)
					objC2D.stroke()
				}
				objC2D.restore()
			}

			function mettreAJourAnimationLoneRunner() {
				if (objLodeRunner.binMovGauche) {
					objLodeRunner.intPosXActuel += objLodeRunner.intVitesse
					objLodeRunner.intScaleX = 1
				} else if (objLodeRunner.binMovDroite) {
					objLodeRunner.intPosXActuel -= objLodeRunner.intVitesse
					objLodeRunner.intScaleX = -1
				}
			}

			const mouvementLoneRunner = () => {
				switch (event.keyCode) {
					case 39:
						objLodeRunner.binMovGauche = true
						objLodeRunner.binMovDroite = false

						break
					case 37:
						objLodeRunner.binMovDroite = true
						objLodeRunner.binMovGauche = false
						break
				}
			}

			const mouvementGarde = () => {
				// if (objLodeRunner.intPosYActuel == objGarde1.intPosYActuel + intHauteurCellule - 2) {
				// 	if (objLodeRunner.intPosXActuel - (objGarde1.intPosXActuel + 50) > 0) {
				// 		objGarde1.intPosXActuel += objGarde1.intVitesse
				// 	} else if (objLodeRunner.intPosXActuel - objGarde1.intPosXActuel < 0)
				// 		objGarde1.intPosXActuel -= objGarde1.intVitesse
				// }
				// if (
				// 	objLodeRunner.intPosXActuel - objGarde1.intPosXActuel <= 50 &&
				// 	objLodeRunner.intPosXActuel - objGarde1.intPosXActuel >= 0
				// ) {
				// 	console.log("Game Over")
				// }

				let objGardeActuel = objGarde3

				// Si le garde est en train de tomber (binTombeActuel)
				if (objGardeActuel.binVaTomber) {
					faireTomber(objGardeActuel)
				}
				// Si le garde n'est pas en train de tomber
				else if (!objGardeActuel.binTombe) {
					// Si le garde se deplace vers la gauche ou la droite
					if (objGardeActuel.binEnMouvement) {
						// Verifier s'il va tomber au prochain refresh
						objGardeActuel.binVaTomber = verifierSiVaTomber(objGardeActuel)
						objGardeActuel.intPosYAvantChute = objGardeActuel.intPosYActuel
					}
					// Si on detecte que le garde ne va pas tomber on change sa position et on indique qu'il est en mouvement
					if (!objGardeActuel.binVaTomber) {
						objGardeActuel.intPosXActuel += objGardeActuel.intVitesse
						objGardeActuel.binEnMouvement = true
					}
					// Si le garde va tomber au prochain refresh
					else if (objGardeActuel.binVaTomber) {
						objGardeActuel.binEnMouvement = false
					}
				}
			}

			function faireTomber(objGarde) {
				let intPosXGarde = objGarde.intPosXActuel
				let intPosYGarde = objGarde.intPosYActuel
				let intIndexProchainePlateforme = trouverProchainePlateforme(
					intPosXGarde,
					objGarde.intPosYAvantChute
				)
				let intIndexBriqueVide = trouverProchainePlateformeVide(intPosXGarde, intPosYGarde)
				// pour faire depasser le garde des briques (amener dans le vide)
				// si la brique est sur la position du garde - la hauteur de la cellule
				if (intPosYGarde == objBrique.tPos[intIndexBriqueVide].y - intHauteurCellule) {
					// si le garde est a gauche du vide
					if (intPosXGarde < objBrique.tPos[intIndexBriqueVide].x + intLongueurCellule) {
						// avance le garde pour le mettre dans le vide
						objGarde.intPosXActuel += objGarde.intVitesse
					} else {
						objGarde.binTombe = true
					}
				}
				// Si le garde est dans le vide
				if (
					Math.round(intPosXGarde) >= objBrique.tPos[intIndexProchainePlateforme].x &&
					Math.round(intPosXGarde) <=
						objBrique.tPos[intIndexProchainePlateforme].x + intLongueurCellule / 2 &&
					objGarde.binTombe
				) {
					// Si le garde n'a pas atteint les prochaines briques en dessous, PosY++
					if (
						objBrique.tPos[intIndexProchainePlateforme].y - intHauteurCellule >
						Math.round(intPosYGarde)
					) {
						objGarde.intPosYActuel += objGarde.intVitesse
					}
					// Si le garde a atteint la position des briques en dessous
					else if (
						objBrique.tPos[intIndexProchainePlateforme].y - intHauteurCellule ==
						Math.round(intPosYGarde)
					) {
						objGarde.binTombe = false
						objGarde.binVaTomber = false
					}
				}
			}

			function trouverProchainePlateforme(intPosX, intPosY) {
				let intIndexObjBrique = 0
				let binTrouvePlateforme = false
				for (let i = 0; i < objBrique.tPos.length && !binTrouvePlateforme; i++) {
					if (
						intPosX >= objBrique.tPos[i].x &&
						intPosX <= objBrique.tPos[i].x + intLongueurCellule / 2 &&
						intPosY < objBrique.tPos[i].y - intHauteurCellule
					) {
						intIndexObjBrique = i
						binTrouvePlateforme = true
					}
				}
				return intIndexObjBrique
			}

			function trouverProchainePlateformeVide(intPosX, intPosY) {
				let intIndexObjBrique = 0
				let binTrouvePlateforme = false
				for (let i = 0; i < objBrique.tPos.length && !binTrouvePlateforme; i++) {
					// Si la position du garde en Y est la meme que celle au dessus de la brique
					if (intPosY == objBrique.tPos[i].y - intHauteurCellule) {
						// Si le garde est sur le bord de changer de brique (pos) (a une demi cellule)
						if (
							intPosX - (intLongueurCellule / 2 - 1) - objBrique.tPos[i].x <= intLongueurCellule &&
							intPosX - (intLongueurCellule / 2 - 1) - objBrique.tPos[i].x >= 0
						) {
							// si la prochaine brique n'esiste pas a cette position X, on fait tomber
							if (objBrique.tPos[i].x + intLongueurCellule != objBrique.tPos[i + 1].x) {
								intIndexObjBrique = i
								binTrouvePlateforme = true
							}
						}
						// Pour regarder a la gauche du garde
						if (
							intPosX +
								(2 * intLongueurCellule - (intLongueurCellule / 2 - 1)) -
								objBrique.tPos[i].x <=
								intLongueurCellule &&
							intPosX +
								(2 * intLongueurCellule - (intLongueurCellule / 2 - 1)) -
								objBrique.tPos[i].x >=
								0
						) {
							if (objBrique.tPos[i].x - intLongueurCellule != objBrique.tPos[i - 1].x) {
								intIndexObjBrique = i
								binTrouvePlateforme = true
							}
						}
					}
				}

				return intIndexObjBrique
			}

			function trouverProchaineEchelle(intPosX, intPosY) {
				let intIndexObjEchelle = 0
				let binTrouveEchelle = false
				for (let i = 0; i < objEchelle.tPos.length && !binTrouveEchelle; i++) {
					// Si la position du garde en Y est la meme que celle au dessus de l'echelle
					if (intPosY == objEchelle.tPos[i].y - intHauteurCellule) {
						if (
							objEchelle.tPos[i].x + intLongueurCellule - intPosX <= 2 * intLongueurCellule &&
							objEchelle.tPos[i].x + intLongueurCellule - intPosX >= 0
						) {
							intIndexObjEchelle = i
							console.log(i)
							binTrouveEchelle = true
						}

						// Si le garde est sur le bord de passer sur une echelle (pos) (a une demi cellule)

						// if (
						// 	intPosX - (intLongueurCellule / 2 - 1) - objEchelle.tPos[i].x <= intLongueurCellule &&
						// 	intPosX - (intLongueurCellule / 2 - 1) - objEchelle.tPos[i].x >= 0
						// ) {
						// 	// si la prochaine echelle n'esiste pas a cette position X, on fait tomber
						// 	//if (objEchelle.tPos[i].x + intLongueurCellule != objEchelle.tPos[i + 1].x) {
						// 	intIndexObjEchelle = i
						// 	binTrouveEchelle = true
						// 	//}
						// }
						// // Pour regarder a la gauche du garde
						// if (
						// 	intPosX +
						// 		(2 * intLongueurCellule - (intLongueurCellule / 2 - 1)) -
						// 		objEchelle.tPos[i].x <=
						// 		intLongueurCellule &&
						// 	intPosX +
						// 		(2 * intLongueurCellule - (intLongueurCellule / 2 - 1)) -
						// 		objEchelle.tPos[i].x >=
						// 		0
						// ) {
						// 	if (objEchelle.tPos[i].x - intLongueurCellule != objEchelle.tPos[i - 1].x) {
						// 		intIndexObjEchelle = i
						// 		binTrouveEchelle = true
						// 	}
						// }
					}
				}
				return intIndexObjEchelle
			}

			function verifierSiVaTomber(objGarde) {
				let intPosXGarde = objGarde.intPosXActuel
				let intPosYGarde = objGarde.intPosYActuel
				let intIndexPosBrique = trouverProchainePlateformeVide(intPosXGarde, intPosYGarde)
				let intIndexPosEchelle = trouverProchaineEchelle(intPosXGarde, intPosYGarde)
				let binVaTomber = false

				//console.log(objEchelle.tPos[intIndexPosEchelle].x)
				// Verifier s'il y a une brique a droite
				if (
					objBrique.tPos[intIndexPosBrique].x + intLongueurCellule !=
					objBrique.tPos[intIndexPosBrique + 1].x //&&
					//intIndexPosEchelle == 0
				) {
					binVaTomber = true
				}
				// else if (
				// 	intIndexPosBrique != 0 &&
				// 	objBrique.tPos[intIndexPosBrique].x + intLongueurCellule !=
				// 		objBrique.tPos[intIndexPosBrique + 2].x &&
				// 	intIndexPosEchelle == 0
				// ) {
				// 	binVaTomber = true
				// }

				// if (

				// ) {
				// 	binVaTomber = false
				// }

				// Verifier s'il y a une brique a gauche gauche
				if (
					intIndexPosBrique != 0 &&
					objBrique.tPos[intIndexPosBrique].x - intLongueurCellule !=
						objBrique.tPos[intIndexPosBrique - 1].x
				) {
					binVaTomber = true
				}

				return binVaTomber
			}
		</script>
	</head>
	<body onload="initAnimation()">
		<main class="sLargeurDiv sCorps">
			<canvas
				id="monCanvas"
				width="1400"
				height="680"
				tabindex="1"
				onkeydown="mouvementLoneRunner(); return false"
				onkeyup="objLodeRunner.binMovGauche = false; objLodeRunner.binMovDroite = false"
			>
				Votre navigateur ne supporte pas la balise canvas
			</canvas>
		</main>
	</body>
</html>
