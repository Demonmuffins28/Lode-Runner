<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">

<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
	<meta name="description" content="Lode Runner" />
	<title>Lode Runner par Marc-Olivier Lalonde</title>
	<link rel="stylesheet" type="text/css" href="StyleLabo5.css" />
	<link rel="javascript" href="echelle.js" />

	<!-- Code JavaScript local -->
	<script type="text/javascript">
		let objCanvas = null
		let objC2D = null
		let objCycleAnimation = null
		let intHauteurCellule = null
		let intLongueurCellule = null

		let objBrique = null
		let objEchelle = null
		let objTextureBois = null
		let objBarreFranchissement = null
		let objImageOr = null
		let objOr = null

		const intVitesse = 2.5

		let objLodeRunner = null

		/*
						" " = case vide (espace dans les guillemets)
						"o" = or
						"b" = brique
						"e" = echelle
						"f" = barre de franchissement
						"p" = plancher gris
					*/
		// prettier-ignore
		let tTableauDeJeu = [
			[" ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
			[" ", " ", " ", " ", "o", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
			["b", "b", "b", "b", "b", "b", "b", "e", "b", "b", "b", "b", "b", "b", "b", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " "],
			[" ", " ", " ", " ", " ", " ", " ", "e", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", " ", " ", " ", " ", " ", "o", " ", " ", " ", " "],
			[" ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", "b", "b", "e", " ", " ", " ", "b", "b", "b", "b", "b", "b", "b", "e", "b", "b"],
			[" ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", "b", "b", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "e", " ", " "],
			[" ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", "b", "b", "e", " ", " ", " ", " ", " ", " ", " ", "o", " ", " ", "e", " ", " "],
			["b", "b", "e", "b", "b", "b", "b", "b", " ", " ", " ", " ", "b", "b", "b", "b", "b", "b", "b", "b", "e", "b", "b", "b", "b", "b", "b", "b"],
			[" ", " ", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", " ", " ", " "],
			[" ", " ", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", " ", " ", " "],
			["b", "b", "b", "b", "b", "b", "b", "b", "b", "e", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "e", " ", " ", " ", " ", " ", " ", " "],
			[" ", " ", " ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "e", " ", " ", " ", " ", " ", " ", " "],
			[" ", " ", " ", " ", " ", " ", " ", "o", " ", "e", "f", "f", "f", "f", "f", "f", "f", "f", "f", "f", "e", " ", " ", " ", "o", " ", " ", " "],
			[" ", " ", " ", " ", "e", "b", "b", "b", "b", "b", "b", " ", " ", " ", " ", " ", " ", " ", " ", " ", "b", "b", "b", "b", "b", "b", "b", "e"],
			[" ", " ", " ", " ", "e", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", " ", "o", " ", " ", " ", " ", " ", " ", " ", " ", "e"],
			["b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b", "b"],
			["p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p", "p"]
		]

		const initAnimation = () => {
			objCanvas = document.getElementById("monCanvas")
			objCanvas.focus()
			objC2D = objCanvas.getContext("2d")
			intLongueurCellule = objCanvas.width / 28
			intHauteurCellule = objCanvas.height / 17
			initFond()
			initBrique()
			initEchelle()
			initBarreFranchissement()
			initOr()
			initTableauJeu()
			initObjLodeRunner()

			dessiner() // Dessiner une première fois
			animer()
		}

		const initFond = () => {
			objFond = new Object()
			objFond.strCouleur = "black"
		}

		const initBrique = () => {
			objBrique = new Object()
			objBrique.tPos = []
			objBrique.strCouleurBrique = "red"
			objBrique.strCouleurCiment = "gray"
		}

		const initEchelle = () => {
			// 50 x 40
			objEchelle = new Object()
			objEchelle.tPos = []
			objEchelle.strCouleur = "#87542D"
		}

		const initBarreFranchissement = () => {
			objBarreFranchissement = new Object()
			objBarreFranchissement.tPos = []
			objBarreFranchissement.strCouleur = "orange"
		}

		const initOr = () => {
			objImageOr = new Image()
			objImageOr.src = "Images/tresor.png"

			objOr = new Object()
			objOr.tPos = []
		}

		const initTableauJeu = () => {
			// intit chaque objet for ij loop pour push position dans chaque objetfixe.
			for (let i = 0; i < tTableauDeJeu.length; i++) {
				for (let j = 0; j < tTableauDeJeu[i].length; j++) {
					switch (tTableauDeJeu[i][j]) {
						case "b":
							objBrique.tPos.push({
								x: j * intLongueurCellule,
								y: i * intHauteurCellule,
							})
							break
						case "e":
							objEchelle.tPos.push({
								x: j * intLongueurCellule,
								y: i * intHauteurCellule,
							})
							break
						case "f":
							objBarreFranchissement.tPos.push({
								x: j * intLongueurCellule,
								y: i * intHauteurCellule,
							})
							break
						case "o":
							objOr.tPos.push({
								x: j * intLongueurCellule,
								y: i * intHauteurCellule,
							})
							break
						default:
							break
					}
				}
			}
		}

		const animer = () => {
			// Requête pour le prochain cycle
			objCycleAnimation = requestAnimationFrame(animer)

			// Le cycle d'animation
			effacerDessin()
			mettreAJourAnimation()
			dessiner()
		}

		const effacerDessin = () => {
			objC2D.clearRect(0, 0, objCanvas.width, objCanvas.height)
		}

		const mettreAJourAnimation = () => {
			mettreAJourAnimationLodeRunner()
		}

		const arreterAnimation = () => {
			if (objCycleAnimation != null) cancelAnimationFrame(objCycleAnimation)
			objCycleAnimation = null
		}

		const dessiner = () => {
			dessinerFond()
			dessinerBrique()
			dessinerEchelle()
			dessinerBarreFranchissement()
			dessinerOr()
			dessinerLodeRunner()
		}

		const dessinerFond = () => {
			objC2D.save()
			objC2D.beginPath()
			objC2D.fillStyle = objFond.strCouleur
			objC2D.rect(0, 0, objCanvas.width, objCanvas.height)
			objC2D.fill()
			objC2D.restore()
		}

		const dessinerBrique = () => {
			objC2D.save()
			for (let index = 0; index < objBrique.tPos.length; index++) {
				let intPosXActuel = objBrique.tPos[index].x
				let intPosYActuel = objBrique.tPos[index].y

				objC2D.fillStyle = "red"
				objC2D.beginPath()
				objC2D.rect(intPosXActuel, intPosYActuel, intLongueurCellule, intHauteurCellule)
				objC2D.fill()

				objC2D.strokeStyle = "gray"
				objC2D.lineWidth = 3
				objC2D.beginPath()
				objC2D.moveTo(intPosXActuel, intPosYActuel)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel)
				objC2D.moveTo(intPosXActuel, intPosYActuel + intHauteurCellule)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + intHauteurCellule)
				objC2D.moveTo(intPosXActuel + intLongueurCellule / 3, intPosYActuel + intHauteurCellule)
				objC2D.lineTo(
					intPosXActuel + intLongueurCellule / 3,
					intPosYActuel + intHauteurCellule / 2
				)
				objC2D.moveTo(intPosXActuel + (2 * intLongueurCellule) / 3, intPosYActuel)
				objC2D.lineTo(
					intPosXActuel + (2 * intLongueurCellule) / 3,
					intPosYActuel + intHauteurCellule / 2
				)
				objC2D.stroke()

				objC2D.strokeStyle = "gray"
				objC2D.lineWidth = 5
				objC2D.beginPath()
				objC2D.moveTo(intPosXActuel, intPosYActuel + intHauteurCellule / 2)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + intHauteurCellule / 2)
				objC2D.stroke()
			}
			objC2D.restore()
		}

		const dessinerEchelle = () => {
			objC2D.save()
			for (let index = 0; index < objEchelle.tPos.length; index++) {
				let intPosXActuel = objEchelle.tPos[index].x
				let intPosYActuel = objEchelle.tPos[index].y

				objC2D.strokeStyle = objEchelle.strCouleur
				objC2D.lineWidth = 5
				objC2D.beginPath()
				// bareau de gauche
				objC2D.moveTo(intPosXActuel + 2.5, intPosYActuel - 1.5)
				objC2D.lineTo(intPosXActuel + 2.5, intPosYActuel + intHauteurCellule - 1)
				objC2D.stroke()
				// bareau de droite
				objC2D.moveTo(intPosXActuel + intLongueurCellule - 2.5, intPosYActuel - 1.5)
				objC2D.lineTo(
					intPosXActuel + intLongueurCellule - 2.5,
					intPosYActuel + intHauteurCellule - 1
				)
				objC2D.stroke()
				objC2D.lineWidth = 2
				// bareau du haut et les autres en dessous
				objC2D.moveTo(intPosXActuel, intPosYActuel + 2)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 2)
				objC2D.moveTo(intPosXActuel, intPosYActuel + 12)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 12)
				objC2D.moveTo(intPosXActuel, intPosYActuel + 22)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 22)
				objC2D.moveTo(intPosXActuel, intPosYActuel + 32)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 32)
				objC2D.stroke()
			}
			let intPosXActuel = objEchelle.tPos[0].x
			let intPosYActuel = objEchelle.tPos[0].y

			objC2D.restore()
		}

		const dessinerBarreFranchissement = () => {
			objC2D.save()
			for (let index = 0; index < objBarreFranchissement.tPos.length; index++) {
				let intPosXActuel = objBarreFranchissement.tPos[index].x
				let intPosYActuel = objBarreFranchissement.tPos[index].y

				objC2D.strokeStyle = objBarreFranchissement.strCouleur
				objC2D.lineWidth = 2
				objC2D.beginPath()
				objC2D.moveTo(intPosXActuel, intPosYActuel + 10)
				objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 10)
				objC2D.stroke()
			}
		}

		const dessinerOr = () => {
			objC2D.save()
			for (let index = 0; index < objOr.tPos.length; index++) {
				let intPosXActuel = objOr.tPos[index].x
				let intPosYActuel = objOr.tPos[index].y

				objC2D.beginPath()
				objC2D.drawImage(
					objImageOr,
					intPosXActuel + 5,
					intPosYActuel + 15,
					intLongueurCellule - 5,
					intHauteurCellule - 15
				)
			}
			objC2D.restore()
		}

		const initObjLodeRunner = () => {
			objLodeRunner = new Object()
			objLodeRunner.intHauteurParRapportSol = 2.5;
			objLodeRunner.intPosXActuel = 10 * intLongueurCellule - intLongueurCellule / 2 + intLongueurCellule / 2
			objLodeRunner.intPosYActuel = 14 * intHauteurCellule + intHauteurCellule - objLodeRunner.intHauteurParRapportSol;
			objLodeRunner.intVitesse = intVitesse;
			objLodeRunner.intScaleX = 1
			objLodeRunner.binMovDroite = false
			objLodeRunner.binMovGauche = false
			objLodeRunner.binMovHaut = false
			objLodeRunner.binMovBas = false
			objLodeRunner.binSurEchelle = false;
			objLodeRunner.binSurBarre = false;
			objLodeRunner.binEnChute = false;
			objLodeRunner.objetAutour = {};
		}

		const touverObjetAutourLodeRunner = () => {
			let intX = Math.floor(objLodeRunner.intPosXActuel / intLongueurCellule);
			let intY = Math.floor(objLodeRunner.intPosYActuel / intHauteurCellule);
			objLodeRunner.objetAutour = {
				objAPosLodeRunner: {
					strType: tTableauDeJeu[intY][intX],
					intX: (intX) * intLongueurCellule,
					intY: (intY) * intHauteurCellule
				},
				objAGauche: {
					strType: tTableauDeJeu[intY][intX + 1],
					intX: (intX + 1) * intLongueurCellule,
					intY: (intY) * intHauteurCellule
				},
				objADroite: {
					strType: tTableauDeJeu[intY][intX - 1],
					intX: (intX - 1) * intLongueurCellule,
					intY: (intY) * intHauteurCellule
				},
				objEnHaut: {
					strType: tTableauDeJeu[intY - 1][intX],
					intX: (intX) * intLongueurCellule,
					intY: (intY - 1) * intHauteurCellule
				},
				objEnBas: {
					strType: tTableauDeJeu[intY + 1][intX],
					intX: (intX) * intLongueurCellule,
					intY: (intY + 1) * intHauteurCellule
				},
				objEnBasAGauche: {
					strType: tTableauDeJeu[intY + 1][intX + 1],
					intX: (intX + 1) * intLongueurCellule,
					intY: (intY + 1) * intHauteurCellule
				},
				objEnBasADroite: {
					strType: tTableauDeJeu[intY + 1][intX - 1],
					intX: (intX - 1) * intLongueurCellule,
					intY: (intY + 1) * intHauteurCellule
				},
				objEnHautAGauche: {
					strType: tTableauDeJeu[intY - 1][intX + 1],
					intX: (intX + 1) * intLongueurCellule,
					intY: (intY - 1) * intHauteurCellule
				},
				objEnHautADroite: {
					strType: tTableauDeJeu[intY - 1][intX - 1],
					intX: (intX - 1) * intLongueurCellule,
					intY: (intY - 1) * intHauteurCellule
				}
			};
		}

		const dessinerLodeRunner = () => {
			objC2D.save()
			objC2D.translate(objLodeRunner.intPosXActuel, objLodeRunner.intPosYActuel)
			objC2D.scale(objLodeRunner.intScaleX, 1)

			objC2D.strokeStyle = "white"
			// pied droit
			objC2D.beginPath()
			objC2D.lineWidth = 6
			objC2D.moveTo(3, 0)
			objC2D.lineTo(3, -7)
			objC2D.stroke()
			// jambe droite
			objC2D.beginPath()
			objC2D.lineWidth = 3
			objC2D.moveTo(1.5, -7)
			objC2D.lineTo(1.5, -11)
			objC2D.stroke()
			// corps
			objC2D.beginPath()
			objC2D.lineWidth = 7
			objC2D.moveTo(-7 / 2, -8)
			objC2D.lineTo(-7 / 2, -20)
			objC2D.stroke()
			// jambe droite
			objC2D.beginPath()
			objC2D.lineWidth = 4
			objC2D.moveTo(-4, -6)
			objC2D.lineTo(-15, -6)
			objC2D.stroke()
			// epaule droite
			objC2D.beginPath()
			objC2D.lineWidth = 3
			objC2D.moveTo(-4, -21.5)
			objC2D.lineTo(6, -21.5)
			objC2D.stroke()
			// bras droite
			objC2D.beginPath()
			objC2D.moveTo(6, -18.5)
			objC2D.lineTo(11, -18.5)
			objC2D.stroke()
			// cou
			objC2D.beginPath()
			objC2D.moveTo(1, -24.5)
			objC2D.lineTo(-7, -24.5)
			objC2D.stroke()
			// epaule gauche
			objC2D.beginPath()
			objC2D.moveTo(-7, -21.5)
			objC2D.lineTo(-12, -21.5)
			objC2D.stroke()
			// bras gauche
			objC2D.beginPath()
			objC2D.moveTo(-10, -18.5)
			objC2D.lineTo(-15, -18.5)
			objC2D.stroke()
			// tete
			objC2D.beginPath()
			objC2D.lineWidth = 8
			objC2D.moveTo(0, -26)
			objC2D.lineTo(0, -32)
			objC2D.stroke()
			// chapeau
			objC2D.beginPath()
			objC2D.strokeStyle = "cyan"
			objC2D.lineWidth = 4
			objC2D.moveTo(0, -32)
			objC2D.lineTo(0, -35)
			objC2D.stroke()

			objC2D.restore()
		}
		function mettreAJourAnimationLodeRunner() {
			touverObjetAutourLodeRunner();
			//chute
			if (objLodeRunner.binSurBarre && objLodeRunner.binMovBas) {
				objLodeRunner.binEnChute = true;
			}

			if (((((objLodeRunner.objetAutour.objAPosLodeRunner.strType == " " || objLodeRunner.objetAutour.objAPosLodeRunner.strType == "f" || objLodeRunner.objetAutour.objAPosLodeRunner.strType == "o") &&
				objLodeRunner.intPosYActuel < (objLodeRunner.objetAutour.objEnBas.intY - objLodeRunner.intHauteurParRapportSol)
				|| (objLodeRunner.objetAutour.objEnBas.strType == " " || objLodeRunner.objetAutour.objEnBas.strType == "f" || objLodeRunner.objetAutour.objEnBas.strType == "o"))
				&& ((objLodeRunner.intPosXActuel - 15 > objLodeRunner.objetAutour.objAPosLodeRunner.intX && objLodeRunner.intScaleX == 1)
					|| (objLodeRunner.intPosXActuel + 15 < objLodeRunner.objetAutour.objAPosLodeRunner.intX + intLongueurCellule && objLodeRunner.intScaleX == -1))) && (!objLodeRunner.binSurBarre)) || objLodeRunner.binEnChute) {
				
				if ((objLodeRunner.objetAutour.objEnBas.strType == "b" || objLodeRunner.objetAutour.objEnBas.strType == "e") && (objLodeRunner.intPosYActuel == objLodeRunner.objetAutour.objEnBas.intY - 2 || (objLodeRunner.intPosYActuel == objLodeRunner.objetAutour.objEnBas.intY - objLodeRunner.intHauteurParRapportSol))) {
					objLodeRunner.binEnChute = false;
				}
				else {
					objLodeRunner.intPosYActuel += objLodeRunner.intVitesse;
					objLodeRunner.binMovDroite = false
					objLodeRunner.binMovGauche = false
					objLodeRunner.binMovHaut = false
				}
			}

			if (objLodeRunner.objetAutour.objAPosLodeRunner.strType == "f" && (objLodeRunner.objetAutour.objAPosLodeRunner.intY + intHauteurCellule - objLodeRunner.intHauteurParRapportSol) == objLodeRunner.intPosYActuel) {
				objLodeRunner.binSurBarre = true;
			}
			else {
				objLodeRunner.binSurBarre = false;
			}

			if (objLodeRunner.binMovGauche && objLodeRunner.intPosXActuel <= objCanvas.width - 15 &&
				!(objLodeRunner.objetAutour.objAGauche.strType == "b" &&
					(objLodeRunner.intPosXActuel + (intLongueurCellule / 2)) == objLodeRunner.objetAutour.objAGauche.intX)) {
				objLodeRunner.intScaleX = 1
				if (!(objLodeRunner.binSurEchelle == true && objLodeRunner.objetAutour.objEnHautAGauche.strType == "b")) {
					objLodeRunner.intPosXActuel += objLodeRunner.intVitesse
					objLodeRunner.binSurEchelle = false;
				}
				if (objLodeRunner.objetAutour.objEnHautAGauche.strType == "f" && objLodeRunner.intPosYActuel <= objLodeRunner.objetAutour.objAPosLodeRunner.intY + (3 * intHauteurCellule / 4)) {
					objLodeRunner.intPosYActuel = objLodeRunner.objetAutour.objEnHautAGauche.intY + intHauteurCellule - objLodeRunner.intHauteurParRapportSol;
				}
			}
			else if (objLodeRunner.binMovDroite && objLodeRunner.intPosXActuel >= 15
				&& !(objLodeRunner.objetAutour.objADroite.strType == "b" &&
					(objLodeRunner.intPosXActuel - (intLongueurCellule / 2) < objLodeRunner.objetAutour.objADroite.intX + intLongueurCellule))) {
				objLodeRunner.intScaleX = -1
				if (!(objLodeRunner.binSurEchelle == true && objLodeRunner.objetAutour.objEnHautADroite.strType == "b")) {
					objLodeRunner.intPosXActuel -= objLodeRunner.intVitesse;
					objLodeRunner.binSurEchelle = false;
				}
			}
			else if (objLodeRunner.binMovHaut) {
				if (objLodeRunner.objetAutour.objAPosLodeRunner.strType == "e") {
					objLodeRunner.intPosXActuel = objLodeRunner.objetAutour.objAPosLodeRunner.intX + (intLongueurCellule / 2)
					objLodeRunner.intPosYActuel -= objLodeRunner.intVitesse;
					objLodeRunner.binSurEchelle = true;
				}
				else {
					objLodeRunner.binSurEchelle = false;
				}
			}
			else if (objLodeRunner.binMovBas) {
				if (((objLodeRunner.objetAutour.objAPosLodeRunner.strType == "e" &&
					(objLodeRunner.objetAutour.objEnBas.strType == "b" &&
						objLodeRunner.intPosYActuel < (objLodeRunner.objetAutour.objEnBas.intY - objLodeRunner.intHauteurParRapportSol))) ||
					objLodeRunner.objetAutour.objEnBas.strType == "e")) {
					objLodeRunner.intPosXActuel = objLodeRunner.objetAutour.objAPosLodeRunner.intX + (intLongueurCellule / 2)
					objLodeRunner.intPosYActuel += objLodeRunner.intVitesse;
					objLodeRunner.binSurEchelle = true;
				}
				else {
					objLodeRunner.binSurEchelle = false;
				}
			}
		}

		const mouvementLodeRunner = () => {
			switch (event.keyCode) {
				case 39:
					objLodeRunner.binMovGauche = true
					break
				case 37:
					objLodeRunner.binMovDroite = true
					break
				case 38:
					objLodeRunner.binMovHaut = true
					break
				case 40:
					objLodeRunner.binMovBas = true
					break
			}
		}
		const arreterMouvementLodeRunner = () => {
			switch (event.keyCode) {
				case 39:
					objLodeRunner.binMovGauche = false
					break
				case 37:
					objLodeRunner.binMovDroite = false
					break
				case 38:
					objLodeRunner.binMovHaut = false
					break
				case 40:
					objLodeRunner.binMovBas = false
					break
			}
		}
	</script>
</head>

<body onload="initAnimation()">
	<main class="sLargeurDiv sCorps">
		<canvas id="monCanvas" width="1400" height="680" tabindex="1" onkeydown="mouvementLodeRunner();"
			onkeyup="arreterMouvementLodeRunner()">
			Votre navigateur ne supporte pas la balise canvas
		</canvas>
	</main>
</body>

</html>