<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="fr" xml:lang="fr">
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
		<meta name="description" content="Lode Runner" />
		<title>Lode Runner par Marc-Olivier Lalonde</title>
		<link rel="stylesheet" type="text/css" href="StyleLabo5.css" />
		<link rel="javascript" href="echelle.js" />

		<!-- Code JavaScript local -->
		<script type="text/javascript">
			let objCanvas = null
			let objC2D = null
			let objCycleAnimation = null
			let intHauteurCellule = null
			let intLongueurCellule = null

			let objBrique = null
			let objEchelle = null
			let objTextureBois = null
			let objBarreFranchissement = null
			let objImageOr = null
			let objOr = null

			let objGarde1 = null
			let objGarde2 = null
			let objGarde3 = null
			let objLodeRunner = null

			const intVitesse = 2.5

			/*
											" " = case vide (espace dans les guillemets)
											"o" = or
											"b" = brique
											"e" = echelle
											"f" = barre de franchissement
											"p" = plancher gris
										*/
			// prettier-ignore
			let tTableauDeJeu = [
																					[" "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "],
																					[" "," "," "," ","o"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "],
																					["b","b","b","b","b","b","b","e","b","b","b","b","b","b","b"," "," "," "," "," "," "," "," "," "," "," "," "," "],
																					[" "," "," "," "," "," "," ","e","f","f","f","f","f","f","f","f","f","f"," "," "," "," "," ","o"," "," "," "," "],
																					[" "," "," "," "," "," "," ","e"," "," "," "," ","b","b","e"," "," "," ","b","b","b","b","b","b","b","e","b","b"],
																					[" "," "," "," "," "," "," ","e"," "," "," "," ","b","b","e"," "," "," "," "," "," "," "," "," "," ","e"," "," "],
																					[" "," "," "," "," "," "," ","e"," "," "," "," ","b","b","e"," "," "," "," "," "," "," ","o"," "," ","e"," "," "],
																					["b","b","e","b","b","b","b","b"," "," "," "," ","b","b","b","b","b","b","b","b","e","b","b","b","b","b","b","b"],
																					[" "," ","e"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "],
																					[" "," ","e"," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "],
																					["b","b","b","b","b","b","b","b","b","e","b","b","b","b","b","b","b","b","b","b","e"," "," "," "," "," "," "," "],
																					[" "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "," "," "," ","e"," "," "," "," "," "," "," "],
																					[" "," "," "," "," "," "," ","o"," ","e","f","f","f","f","f","f","f","f","f","f","e"," "," "," ","o"," "," "," "],
																					[" "," "," "," ","e","b","b","b","b","b","b"," "," "," "," "," "," "," "," "," ","b","b","b","b","b","b","b","e"],
																					[" "," "," "," ","e"," "," "," "," "," "," "," "," "," "," "," "," "," ","o"," "," "," "," "," "," "," "," ","e"],
																					["b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b","b"],
																					["p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p","p"]
																				]

			const initAnimation = () => {
				objCanvas = document.getElementById("monCanvas")
				objCanvas.focus()
				objC2D = objCanvas.getContext("2d")
				intLongueurCellule = objCanvas.width / 28
				intHauteurCellule = objCanvas.height / 17
				initFond()
				initBrique()
				initEchelle()
				initBarreFranchissement()
				initOr()
				initTableauJeu()
				initObjLodeRunner()
				initGardes()

				//console.log(objGarde1.intPosYActuel)
				//console.table(objBrique.tPos)

				dessiner() // Dessiner une première fois
				animer()
			}

			const initFond = () => {
				objFond = new Object()
				objFond.strCouleur = "black"
			}

			const initBrique = () => {
				objBrique = new Object()
				objBrique.tPos = []
				objBrique.strCouleurBrique = "red"
				objBrique.strCouleurCiment = "gray"
			}

			const initEchelle = () => {
				// 50 x 40
				objEchelle = new Object()
				objEchelle.tPos = []
				objEchelle.strCouleur = "#87542D"
			}

			const initBarreFranchissement = () => {
				objBarreFranchissement = new Object()
				objBarreFranchissement.tPos = []
				objBarreFranchissement.strCouleur = "orange"
			}

			const initOr = () => {
				objImageOr = new Image()
				objImageOr.src = "Images/tresor.png"

				objOr = new Object()
				objOr.tPos = []
			}

			const initTableauJeu = () => {
				// intit chaque objet for ij loop pour push position dans chaque objetfixe.
				for (let i = 0; i < tTableauDeJeu.length; i++) {
					for (let j = 0; j < tTableauDeJeu[i].length; j++) {
						switch (tTableauDeJeu[i][j]) {
							case "b":
								objBrique.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							case "e":
								objEchelle.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							case "f":
								objBarreFranchissement.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							case "o":
								objOr.tPos.push({
									x: j * intLongueurCellule,
									y: i * intHauteurCellule,
								})
								break
							default:
								break
						}
					}
				}
			}

			const initGardes = () => {
				objGarde1 = new Object()
				objGarde1.intPosXActuel = 22 * intLongueurCellule
				objGarde1.intPosYActuel = 12 * intHauteurCellule
				objGarde1.strCouleur = "red"
				objGarde1.intVitesse = intVitesse
				objGarde1.intScaleX = 1
				objGarde1.binMovDroite = false
				objGarde1.binMovGauche = false
				objGarde1.binMovHaut = false
				objGarde1.binMovBas = false
				objGarde1.binSurEchelle = false
				objGarde1.binSurBarre = false
				objGarde1.binEnChute = false
				objGarde1.objetAutour = {}

				objGarde2 = new Object()
				objGarde2.intPosXActuel = 8 * intLongueurCellule
				objGarde2.intPosYActuel = 9 * intHauteurCellule
				objGarde2.strCouleur = "green"
				objGarde2.intVitesse = intVitesse * 0.8
				objGarde2.intScaleX = 1
				objGarde2.binMovDroite = false
				objGarde2.binMovGauche = false
				objGarde2.binMovHaut = false
				objGarde2.binMovBas = false
				objGarde2.binSurEchelle = false
				objGarde2.binSurBarre = false
				objGarde2.binEnChute = false
				objGarde2.objetAutour = {}

				objGarde3 = new Object()
				objGarde3.intPosXActuel = 12 * intLongueurCellule
				objGarde3.intPosYActuel = 3 * intHauteurCellule
				objGarde3.strCouleur = "purple"
				objGarde3.intVitesse = intVitesse * 0.8
				objGarde3.intScaleX = 1
				objGarde3.binMovDroite = false
				objGarde3.binMovGauche = false
				objGarde3.binMovHaut = false
				objGarde3.binMovBas = false
				objGarde3.binSurEchelle = false
				objGarde3.binSurBarre = false
				objGarde3.binEnChute = false
				objGarde3.objetAutour = {}
			}

			const animer = () => {
				// Requête pour le prochain cycle
				objCycleAnimation = requestAnimationFrame(animer)

				// Le cycle d'animation
				effacerDessin()
				mettreAJourAnimation()
				dessiner()
			}

			const effacerDessin = () => {
				objC2D.clearRect(0, 0, objCanvas.width, objCanvas.height)
			}

			const mettreAJourAnimation = () => {
				mettreAJourAnimationLoneRunner()
				mettreAJourAnimPerso()
				algorithmeGarde()
			}

			const arreterAnimation = () => {
				if (objCycleAnimation != null) cancelAnimationFrame(objCycleAnimation)
				objCycleAnimation = null
			}

			const dessiner = () => {
				dessinerFond()
				dessinerBrique()
				dessinerEchelle()
				dessinerBarreFranchissement()
				dessinerOr()
				dessinerLodeRunner()
				dessinerGardes()
			}

			const dessinerFond = () => {
				objC2D.save()
				objC2D.beginPath()
				objC2D.fillStyle = objFond.strCouleur
				objC2D.rect(0, 0, objCanvas.width, objCanvas.height)
				objC2D.fill()
				objC2D.restore()
			}

			const dessinerBrique = () => {
				objC2D.save()
				for (let index = 0; index < objBrique.tPos.length; index++) {
					let intPosXActuel = objBrique.tPos[index].x
					let intPosYActuel = objBrique.tPos[index].y

					objC2D.fillStyle = "red"
					objC2D.beginPath()
					objC2D.rect(intPosXActuel, intPosYActuel, intLongueurCellule, intHauteurCellule)
					objC2D.fill()

					objC2D.strokeStyle = "gray"
					objC2D.lineWidth = 3
					objC2D.beginPath()
					objC2D.moveTo(intPosXActuel, intPosYActuel)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel)
					objC2D.moveTo(intPosXActuel, intPosYActuel + intHauteurCellule)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + intHauteurCellule)
					objC2D.moveTo(intPosXActuel + intLongueurCellule / 3, intPosYActuel + intHauteurCellule)
					objC2D.lineTo(
						intPosXActuel + intLongueurCellule / 3,
						intPosYActuel + intHauteurCellule / 2
					)
					objC2D.moveTo(intPosXActuel + (2 * intLongueurCellule) / 3, intPosYActuel)
					objC2D.lineTo(
						intPosXActuel + (2 * intLongueurCellule) / 3,
						intPosYActuel + intHauteurCellule / 2
					)
					objC2D.stroke()

					objC2D.strokeStyle = "gray"
					objC2D.lineWidth = 5
					objC2D.beginPath()
					objC2D.moveTo(intPosXActuel, intPosYActuel + intHauteurCellule / 2)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + intHauteurCellule / 2)
					objC2D.stroke()
				}
				objC2D.restore()
			}

			const dessinerEchelle = () => {
				objC2D.save()
				for (let index = 0; index < objEchelle.tPos.length; index++) {
					let intPosXActuel = objEchelle.tPos[index].x
					let intPosYActuel = objEchelle.tPos[index].y

					objC2D.strokeStyle = objEchelle.strCouleur
					objC2D.lineWidth = 5
					objC2D.beginPath()
					// bareau de gauche
					objC2D.moveTo(intPosXActuel + 2.5, intPosYActuel - 1.5)
					objC2D.lineTo(intPosXActuel + 2.5, intPosYActuel + intHauteurCellule - 1)
					objC2D.stroke()
					// bareau de droite
					objC2D.moveTo(intPosXActuel + intLongueurCellule - 2.5, intPosYActuel - 1.5)
					objC2D.lineTo(
						intPosXActuel + intLongueurCellule - 2.5,
						intPosYActuel + intHauteurCellule - 1
					)
					objC2D.stroke()
					objC2D.lineWidth = 2
					// bareau du haut et les autres en dessous
					objC2D.moveTo(intPosXActuel, intPosYActuel + 2)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 2)
					objC2D.moveTo(intPosXActuel, intPosYActuel + 12)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 12)
					objC2D.moveTo(intPosXActuel, intPosYActuel + 22)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 22)
					objC2D.moveTo(intPosXActuel, intPosYActuel + 32)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 32)
					objC2D.stroke()
				}
				let intPosXActuel = objEchelle.tPos[0].x
				let intPosYActuel = objEchelle.tPos[0].y

				objC2D.restore()
			}

			const dessinerBarreFranchissement = () => {
				objC2D.save()
				for (let index = 0; index < objBarreFranchissement.tPos.length; index++) {
					let intPosXActuel = objBarreFranchissement.tPos[index].x
					let intPosYActuel = objBarreFranchissement.tPos[index].y

					objC2D.strokeStyle = objBarreFranchissement.strCouleur
					objC2D.lineWidth = 2
					objC2D.beginPath()
					objC2D.moveTo(intPosXActuel, intPosYActuel + 10)
					objC2D.lineTo(intPosXActuel + intLongueurCellule, intPosYActuel + 10)
					objC2D.stroke()
				}
			}

			const dessinerOr = () => {
				objC2D.save()
				for (let index = 0; index < objOr.tPos.length; index++) {
					let intPosXActuel = objOr.tPos[index].x
					let intPosYActuel = objOr.tPos[index].y

					objC2D.beginPath()
					objC2D.drawImage(
						objImageOr,
						intPosXActuel + 5,
						intPosYActuel + 15,
						intLongueurCellule - 5,
						intHauteurCellule - 15
					)
				}
				objC2D.restore()
			}

			const initObjLodeRunner = () => {
				objLodeRunner = new Object()
				objLodeRunner.intHauteurParRapportSol = 2.5
				objLodeRunner.intPosXActuel =
					11 * intLongueurCellule - intLongueurCellule / 2 + intLongueurCellule / 2
				objLodeRunner.intPosYActuel =
					9 * intHauteurCellule + intHauteurCellule - objLodeRunner.intHauteurParRapportSol
				objLodeRunner.intVitesse = intVitesse
				objLodeRunner.intScaleX = 1
				objLodeRunner.binMovDroite = false
				objLodeRunner.binMovGauche = false
				objLodeRunner.binMovHaut = false
				objLodeRunner.binMovBas = false
				objLodeRunner.binSurEchelle = false
				objLodeRunner.binSurBarre = false
				objLodeRunner.binEnChute = false
				objLodeRunner.objetAutour = {}
			}

			const dessinerLodeRunner = () => {
				objC2D.save()
				objC2D.translate(objLodeRunner.intPosXActuel, objLodeRunner.intPosYActuel)
				objC2D.scale(objLodeRunner.intScaleX, 1)

				objC2D.strokeStyle = "white"
				// pied droit
				objC2D.beginPath()
				objC2D.lineWidth = 6
				objC2D.moveTo(3, 0)
				objC2D.lineTo(3, -7)
				objC2D.stroke()
				// jambe droite
				objC2D.beginPath()
				objC2D.lineWidth = 3
				objC2D.moveTo(1.5, -7)
				objC2D.lineTo(1.5, -11)
				objC2D.stroke()
				// corps
				objC2D.beginPath()
				objC2D.lineWidth = 7
				objC2D.moveTo(-7 / 2, -8)
				objC2D.lineTo(-7 / 2, -20)
				objC2D.stroke()
				// jambe droite
				objC2D.beginPath()
				objC2D.lineWidth = 4
				objC2D.moveTo(-4, -6)
				objC2D.lineTo(-15, -6)
				objC2D.stroke()
				// epaule droite
				objC2D.beginPath()
				objC2D.lineWidth = 3
				objC2D.moveTo(-4, -21.5)
				objC2D.lineTo(6, -21.5)
				objC2D.stroke()
				// bras droite
				objC2D.beginPath()
				objC2D.moveTo(6, -18.5)
				objC2D.lineTo(11, -18.5)
				objC2D.stroke()
				// cou
				objC2D.beginPath()
				objC2D.moveTo(1, -24.5)
				objC2D.lineTo(-7, -24.5)
				objC2D.stroke()
				// epaule gauche
				objC2D.beginPath()
				objC2D.moveTo(-7, -21.5)
				objC2D.lineTo(-12, -21.5)
				objC2D.stroke()
				// bras gauche
				objC2D.beginPath()
				objC2D.moveTo(-10, -18.5)
				objC2D.lineTo(-15, -18.5)
				objC2D.stroke()
				// tete
				objC2D.beginPath()
				objC2D.lineWidth = 8
				objC2D.moveTo(0, -26)
				objC2D.lineTo(0, -32)
				objC2D.stroke()
				// chapeau
				objC2D.beginPath()
				objC2D.strokeStyle = "cyan"
				objC2D.lineWidth = 4
				objC2D.moveTo(0, -32)
				objC2D.lineTo(0, -35)
				objC2D.stroke()

				objC2D.restore()
			}

			const dessinerGardes = () => {
				objC2D.save()
				let intPosXActuel = null
				let intPosYActuel = null
				let strCouleurGarde = ""
				let scaleX = null

				for (let i = 1; i <= 3; i++) {
					objC2D.save()
					if (i == 1) {
						strCouleurGarde = objGarde1.strCouleur
						objC2D.translate(
							objGarde1.intPosXActuel + intLongueurCellule / 2,
							objGarde1.intPosYActuel + intHauteurCellule - 2
						)
						scaleX = objGarde1.intScaleX
					} else if (i == 2) {
						strCouleurGarde = objGarde2.strCouleur
						objC2D.translate(
							objGarde2.intPosXActuel + intLongueurCellule / 2,
							objGarde2.intPosYActuel + intHauteurCellule - 2
						)
						scaleX = objGarde2.intScaleX
					} else {
						strCouleurGarde = objGarde3.strCouleur
						objC2D.translate(
							objGarde3.intPosXActuel + intLongueurCellule / 2,
							objGarde3.intPosYActuel + intHauteurCellule - 2
						)
						scaleX = objGarde3.intScaleX
					}

					objC2D.scale(scaleX, 1)
					intPosPlancherY = intPosYActuel
					intPosCentreX = intPosXActuel

					// Dessiner a partir du base au centre de la cellule
					objC2D.strokeStyle = "white"
					// pied droit
					objC2D.beginPath()
					objC2D.lineWidth = 6
					objC2D.moveTo(intPosCentreX + 3, intPosPlancherY)
					objC2D.lineTo(intPosCentreX + 3, intPosPlancherY - 7)
					objC2D.stroke()
					// jambe droite
					objC2D.beginPath()
					objC2D.lineWidth = 3
					objC2D.moveTo(intPosCentreX + 1.5, intPosPlancherY - 7)
					objC2D.lineTo(intPosCentreX + 1.5, intPosPlancherY - 11)
					objC2D.stroke()
					// fesse
					objC2D.strokeStyle = "white"
					objC2D.beginPath()
					objC2D.lineWidth = 7
					objC2D.moveTo(intPosCentreX - 7 / 2, intPosPlancherY - 8)
					objC2D.lineTo(intPosCentreX - 7 / 2, intPosPlancherY - 16)
					objC2D.stroke()
					// corps
					objC2D.strokeStyle = strCouleurGarde
					objC2D.beginPath()
					objC2D.lineWidth = 7
					objC2D.moveTo(intPosCentreX - 7 / 2, intPosPlancherY - 16)
					objC2D.lineTo(intPosCentreX - 7 / 2, intPosPlancherY - 20)
					objC2D.stroke()
					objC2D.strokeStyle = "white"
					// jambe droite
					objC2D.beginPath()
					objC2D.lineWidth = 4
					objC2D.moveTo(intPosCentreX - 4, intPosPlancherY - 6)
					objC2D.lineTo(intPosCentreX - 15, intPosPlancherY - 6)
					objC2D.stroke()
					objC2D.strokeStyle = strCouleurGarde
					// epaule droite
					objC2D.beginPath()
					objC2D.lineWidth = 3
					objC2D.moveTo(intPosCentreX - 4, intPosPlancherY - 21.5)
					objC2D.lineTo(intPosCentreX + 6, intPosPlancherY - 21.5)
					objC2D.stroke()
					// bras droite
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX + 6, intPosPlancherY - 18.5)
					objC2D.lineTo(intPosCentreX + 11, intPosPlancherY - 18.5)
					objC2D.stroke()
					// cou
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX + 1, intPosPlancherY - 24.5)
					objC2D.lineTo(intPosCentreX - 7, intPosPlancherY - 24.5)
					objC2D.stroke()
					// epaule gauche
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX - 7, intPosPlancherY - 21.5)
					objC2D.lineTo(intPosCentreX - 12, intPosPlancherY - 21.5)
					objC2D.stroke()
					// bras gauche
					objC2D.beginPath()
					objC2D.moveTo(intPosCentreX - 10, intPosPlancherY - 18.5)
					objC2D.lineTo(intPosCentreX - 15, intPosPlancherY - 18.5)
					objC2D.stroke()
					objC2D.strokeStyle = "BurlyWood"
					// tete
					objC2D.beginPath()
					objC2D.lineWidth = 8
					objC2D.moveTo(intPosCentreX, intPosPlancherY - 26)
					objC2D.lineTo(intPosCentreX, intPosPlancherY - 32)
					objC2D.stroke()
					// chapeau
					objC2D.beginPath()
					objC2D.strokeStyle = "cyan"
					objC2D.lineWidth = 4
					objC2D.moveTo(intPosCentreX, intPosPlancherY - 32)
					objC2D.lineTo(intPosCentreX, intPosPlancherY - 35)
					objC2D.stroke()
					objC2D.restore()
				}
				objC2D.restore()
			}

			function mettreAJourAnimationLoneRunner() {
				if (objLodeRunner.binMovGauche) {
					objLodeRunner.intPosXActuel += objLodeRunner.intVitesse
					objLodeRunner.intScaleX = 1
				} else if (objLodeRunner.binMovDroite) {
					objLodeRunner.intPosXActuel -= objLodeRunner.intVitesse
					objLodeRunner.intScaleX = -1
				}
			}

			const mouvementLoneRunner = () => {
				switch (event.keyCode) {
					case 39:
						objLodeRunner.binMovGauche = true
						objLodeRunner.binMovDroite = false

						break
					case 37:
						objLodeRunner.binMovDroite = true
						objLodeRunner.binMovGauche = false
						break
				}
			}

			const trouverObjetAutourPerso = (objPerso) => {
				let intX = Math.floor(
					(objPerso.intPosXActuel + intLongueurCellule / 2) / intLongueurCellule
				)
				let intY = Math.floor(objPerso.intPosYActuel / intHauteurCellule)
				objPerso.objetAutour = {
					objAPosPerso: {
						strType: tTableauDeJeu[intY][intX],
						intX: intX * intLongueurCellule,
						intY: intY * intHauteurCellule,
					},
					objADroite: {
						strType: tTableauDeJeu[intY][intX + 1],
						intX: (intX + 1) * intLongueurCellule,
						intY: intY * intHauteurCellule,
					},
					objAGauche: {
						strType: tTableauDeJeu[intY][intX - 1],
						intX: (intX - 1) * intLongueurCellule,
						intY: intY * intHauteurCellule,
					},
					objEnHaut: {
						strType: tTableauDeJeu[intY - 1][intX],
						intX: intX * intLongueurCellule,
						intY: (intY - 1) * intHauteurCellule,
					},
					objEnBas: {
						strType: tTableauDeJeu[intY + 1][intX],
						intX: intX * intLongueurCellule,
						intY: (intY + 1) * intHauteurCellule,
					},
					objEnBasADroite: {
						strType: tTableauDeJeu[intY + 1][intX + 1],
						intX: (intX + 1) * intLongueurCellule,
						intY: (intY + 1) * intHauteurCellule,
					},
					objEnBasAGauche: {
						strType: tTableauDeJeu[intY + 1][intX - 1],
						intX: (intX - 1) * intLongueurCellule,
						intY: (intY + 1) * intHauteurCellule,
					},
					objEnHautADroite: {
						strType: tTableauDeJeu[intY - 1][intX + 1],
						intX: (intX + 1) * intLongueurCellule,
						intY: (intY - 1) * intHauteurCellule,
					},
					objEnHautAGauche: {
						strType: tTableauDeJeu[intY - 1][intX - 1],
						intX: (intX - 1) * intLongueurCellule,
						intY: (intY - 1) * intHauteurCellule,
					},
				}
			}

			const mettreAJourAnimPerso = () => {
				let objPerso = objGarde1
				trouverObjetAutourPerso(objPerso)
				// console.log(
				// 	"Pos Perso: " +
				// 		objPerso.intPosYActuel +
				// 		", Pos Obj A Perso: " +
				// 		objPerso.objetAutour.objAPosPerso.intY
				// )
				// console.log(
				// 	objGarde1.binMovGauche +
				// 		", " +
				// 		objGarde1.binMovDroite +
				// 		", " +
				// 		objGarde1.binMovHaut +
				// 		", " +
				// 		objGarde1.binMovBas +
				// 		", " +
				// 		objGarde1.binSurEchelle
				// )
				if (
					objPerso.binSurBarre &&
					objPerso.binMovBas &&
					objPerso.objetAutour.objEnBas.strType != "e"
				) {
					// Le mettre en chute
					objPerso.binEnChute = true
				}

				if (
					((objPerso.objetAutour.objEnBas.strType == " " ||
						objPerso.objetAutour.objEnBas.strType == "f" ||
						objPerso.objetAutour.objEnBas.strType == "o") &&
						((objPerso.intPosXActuel >= objPerso.objetAutour.objAPosPerso.intX &&
							objPerso.intScaleX == 1) ||
							(objPerso.intPosXActuel <= objPerso.objetAutour.objAPosPerso.intX &&
								objPerso.intScaleX == -1)) &&
						!objPerso.binSurBarre) ||
					objPerso.binEnChute
				) {
					// S'il y a un bloc ou une echelle en dessous, ne chute pas
					if (
						(objPerso.objetAutour.objEnBas.strType == "b" ||
							objPerso.objetAutour.objEnBas.strType == "e") &&
						objPerso.intPosYActuel == objPerso.objetAutour.objEnBas.intY - intHauteurCellule
					) {
						objPerso.binEnChute = false
					}
					// S'il peut continuer a chuter, augmentes sa position en Y
					else {
						objPerso.binEnChute = true
						objPerso.intPosYActuel += objPerso.intVitesse
						objPerso.binMovDroite = false
						objPerso.binMovGauche = false
						objPerso.binMovHaut = false
					}
				}

				//S'il y a une barre de franchissement autour du perso
				if (
					objPerso.objetAutour.objAPosPerso.strType == "f" &&
					objPerso.objetAutour.objAPosPerso.intY == objPerso.intPosYActuel
				) {
					objPerso.binSurBarre = true
				} else {
					objPerso.binSurBarre = false
				}
				// si on veux se deplace a gauche et on nest pas au extremite du jeu et qu'il ny a pas de bloc et asser de place pour tourner
				if (
					objPerso.binMovGauche &&
					objPerso.intPosXActuel >= -5 &&
					!(
						objPerso.objetAutour.objAGauche.strType == "b" &&
						objPerso.intPosXActuel - intLongueurCellule == objPerso.objetAutour.objAGauche.intX
					)
				) {
					objPerso.intScaleX = -1
					// S'il n'y a pas dechelle ou de brique, on ce deplace a droite
					if (
						!(
							objPerso.binSurEchelle == true && objPerso.objetAutour.objEnHautAGauche.strType == "b"
						)
					) {
						objPerso.intPosXActuel -= objPerso.intVitesse
						objPerso.binSurEchelle = false
					}
					// Si il y a un barre en haut a gauche et que le perso n'est pas trop haut
					if (
						objPerso.objetAutour.objEnHautAGauche.strType == "f" &&
						objPerso.intPosYActuel <=
							objPerso.objetAutour.objAPosPerso.intY + (3 * intHauteurCellule) / 4
					) {
						objPerso.intPosYActuel = objPerso.objetAutour.objEnHautAGauche.intY + intHauteurCellule
					}
				}
				// Si le perso veux se deplace vers la droite et qu'il peux se deplacer, on le tourne de cote
				else if (
					objPerso.binMovDroite &&
					objPerso.intPosXActuel + intLongueurCellule <= objCanvas.width + 10 &&
					!(
						objPerso.objetAutour.objADroite.strType == "b" &&
						objPerso.intPosXActuel - intLongueurCellule / 2 <
							objPerso.objetAutour.objADroite.intX + intLongueurCellule
					)
				) {
					objPerso.intScaleX = 1
					// si le perso n'est pas sur une echelle et qu'il n'y a pas de bloque en haut a droite
					// il peu bouger vers la gauche
					if (
						!(
							objPerso.binSurEchelle == true && objPerso.objetAutour.objEnHautADroite.strType == "b"
						)
					) {
						objPerso.intPosXActuel += objPerso.intVitesse
						objPerso.binSurEchelle = false
					}
				}
				// Si le perso veux ce deplace vers le haut
				else if (objPerso.binMovHaut) {
					// Si il y a une echelle autour, accroche le au centre de l'echelle
					if (
						objPerso.objetAutour.objAPosPerso.strType == "e" ||
						objPerso.objetAutour.objAPosPerso.strType == " " ||
						(objPerso.objetAutour.objAPosPerso.strType == "f" &&
							objPerso.objetAutour.objEnBas.strType == "e")
					) {
						objPerso.intPosXActuel = objPerso.objetAutour.objAPosPerso.intX
						objPerso.intPosYActuel -= objPerso.intVitesse
						objPerso.binSurEchelle = true
					}
					// S'il n'y a pas dechelle pour s'acrocher
					else {
						objPerso.binSurEchelle = false
						objPerso.intPosYActuel = objPerso.objetAutour.objAPosPerso.intY
					}
				}
				// Si le perso veux ce deplace vers le bas
				else if (objPerso.binMovBas) {
					// S'il est sur une echelle et qu'il y a une brique en dessous et qu'il peu encore descendre ou
					// s'il y a une echelle en dessous
					if (
						(objPerso.objetAutour.objAPosPerso.strType == "e" &&
							objPerso.objetAutour.objEnBas.strType == "b" &&
							objPerso.intPosYActuel + intHauteurCellule < objPerso.objetAutour.objEnBas.intY) ||
						objPerso.objetAutour.objEnBas.strType == "e"
					) {
						objPerso.intPosXActuel = objPerso.objetAutour.objAPosPerso.intX
						objPerso.intPosYActuel += objPerso.intVitesse
						objPerso.binSurEchelle = true
					} else {
						objPerso.binSurEchelle = false
					}
				}
			}

			const mouvementPerso = () => {
				objPerso = objGarde1
				switch (event.keyCode) {
					case 37:
						objPerso.binMovGauche = true
						break
					case 39:
						objPerso.binMovDroite = true
						break
					case 38:
						objPerso.binMovHaut = true
						break
					case 40:
						objPerso.binMovBas = true
						break
				}
			}
			const arreterMouvementPerso = () => {
				objPerso = objGarde1
				switch (event.keyCode) {
					case 37:
						objPerso.binMovGauche = false
						break
					case 39:
						objPerso.binMovDroite = false
						break
					case 38:
						objPerso.binMovHaut = false
						break
					case 40:
						objPerso.binMovBas = false
						break
				}
			}

			const algorithmeGarde = () => {
				// console.log(
				// 	objLodeRunner.intPosYActuel -
				// 		intHauteurCellule +
				// 		objLodeRunner.intVitesse +
				// 		", " +
				// 		objGarde1.intPosYActuel
				// )
				// Si le garde est au meme etage que lodeRunner
				if (
					objLodeRunner.intPosYActuel - intHauteurCellule + objLodeRunner.intVitesse ==
					objGarde1.intPosYActuel
				) {
					// Va a droite si la position du garde est plus petite que celle de lode runner
					if (
						objLodeRunner.intPosXActuel - (objGarde1.intPosXActuel + intLongueurCellule / 2) >
						0
					) {
						objGarde1.binMovGauche = false
						objGarde1.binMovHaut = false
						objGarde1.binMovBas = false
						objGarde1.binMovDroite = true
					}
					// Va a gauche si la position du garde est plus grande que celle de lode runner
					else if (
						objLodeRunner.intPosXActuel - (objGarde1.intPosXActuel + intLongueurCellule / 2) <
						0
					) {
						objGarde1.binMovDroite = false
						objGarde1.binMovHaut = false
						objGarde1.binMovBas = false
						objGarde1.binMovGauche = true
					}
				} else if (
					/* Si on est pas sur le meme etage que lode runner
				 on veux choisir un cote ou aller si on ne bouge pas (au hazard)
				 Si on attein une echelle, on verifie la position du lode runner pour decider d'y monter ou d'y descendre
				 Si on ne peux pas monter descendre lechelle on monte
				*/
					objLodeRunner.intPosYActuel - intHauteurCellule + objLodeRunner.intVitesse !=
					objGarde1.intPosYActuel
				) {
					// Si on n'est pas en mouvement
					if (
						!objGarde1.binMovDroite &&
						!objGarde1.binMovGauche &&
						!objGarde1.binMovHaut &&
						!objGarde1.binMovBas &&
						!objGarde1.binEnChute &&
						!objGarde1.binSurEchelle &&
						objGarde1.objetAutour.objAPosPerso.strType != "e"
					) {
						let intRanMovement = Math.floor(Math.random() * 2)
						if (intRanMovement == 0) {
							objGarde1.binMovGauche = true
						} else {
							objGarde1.binMovDroite = true
						}
					}
					// Si on est en mouvement
					else {
						// Si il y a une echelle a la position ou en dessous du garde
						if (
							objGarde1.objetAutour.objAPosPerso.strType == "e" ||
							objGarde1.objetAutour.objEnBas.strType == "e"
						) {
							// Si le garde est en haut du lode runner et qu'il y a une echelle en dessous
							if (
								objLodeRunner.intPosYActuel - intHauteurCellule + objLodeRunner.intVitesse >
									objGarde1.intPosYActuel &&
								objGarde1.objetAutour.objEnBas.strType == "e"
							) {
								if (objGarde1.objetAutour.objEnBas.strType == "e") {
									console.log("Bas")
									objGarde1.binMovBas = true
									objGarde1.binMovGauche = false
									objGarde1.binMovDroite = false
								}
							}
							// si on est plus bas que le lode runner et qu'il y a une echelle pour monter
							else if (
								objLodeRunner.intPosYActuel - intHauteurCellule + objLodeRunner.intVitesse <
									objGarde1.intPosYActuel &&
								objGarde1.objetAutour.objAPosPerso.strType == "e"
							) {
								console.log("Huat")
								objGarde1.binMovhaut = true
								objGarde1.binMovGauche = false
								objGarde1.binMovDroite = false
							}
						}
					}
				}

				// Si on attrape lode runner
				if (
					objLodeRunner.intPosXActuel - objGarde1.intPosXActuel <= intLongueurCellule &&
					objLodeRunner.intPosXActuel - objGarde1.intPosXActuel >= 0 &&
					objLodeRunner.intPosYActuel - intHauteurCellule + objLodeRunner.intVitesse ==
						objGarde1.intPosYActuel
				) {
					console.log("Game Over")
					objGarde1.binMovDroite = false
					objGarde1.binMovGauche = false
					objGarde1.binMovHaut = false
					objGarde1.binMovBas = false
				}
			}
		</script>
	</head>
	<body onload="initAnimation()">
		<main class="sLargeurDiv sCorps">
			<canvas
				id="monCanvas"
				width="1400"
				height="680"
				tabindex="1"
				onkeydown="mouvementPerso();"
				onkeyup="arreterMouvementPerso()"
			>
				Votre navigateur ne supporte pas la balise canvas
			</canvas>
		</main>
	</body>
</html>
